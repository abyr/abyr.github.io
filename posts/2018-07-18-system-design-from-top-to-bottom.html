<html>
<head>
		<link rel="Stylesheet" type="text/css" href="style.css" />
		<title>Проектирование системы сверху вниз</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bdc32b9dc15cb1f\"></script>
     <script type=\"text/javascript\">
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-105032758-1', 'auto');
       ga('send', 'pageview');
    </script>

    <nav>
      <ul>
        <li>
          <a href="/">Index</a>
        </li>
      </ul>
    </nav>

    <h1>Проектирование системы сверху вниз</h1>
		<div class="content">
<div id="Contents" class="toc"><h1 id="Contents">Contents</a></h1></div>
<ul>
<li>
<a href="2018-07-18-system-design-from-top-to-bottom.html#Основная задача">Основная задача</a>

<li>
<a href="2018-07-18-system-design-from-top-to-bottom.html#Проектирование">Проектирование</a>

<li>
<a href="2018-07-18-system-design-from-top-to-bottom.html#Недостатки">Недостатки</a>

<li>
<a href="2018-07-18-system-design-from-top-to-bottom.html#Решения">Решения</a>

</ul>



<div id="Основная задача"><h1 id="Основная задача" class="header"><a href="#Основная задача">Основная задача</a></h1></div>

<p>
Основной задачей проектирования системы является определение ее основных компонентов, а также способа их взаимодействия друг с другом и окружением.
</p>
<blockquote>
The purpose of the System Design is to supplement the system architecture providing information and data useful and necessary for implementation of the system elements. Design definition is the process of developing,
expressing, documenting, and communicating the realization of the architecture of the system through a complete set of design characteristics described in a form suitable for implementation.
-- <a href="http://www.sebokwiki.org/wiki/System_Design">Guide to the Systems Engineering Body of Knowledge (SEBoK), 2012</a>
</blockquote>

<p>
Цель разработки системы — дополнить архитектуру системы, предоставляя информацию и данные, полезные и необходимые для реализации элементов системы. Проектирование системы— это процесс разработки, описания, документирования и передачи информации о реализации архитектуры системы посредством полного набора конструктивных характеристик, описанных в форме, подходящей для реализации.
</p>
<blockquote>
Под «проектированием ПО» понимают разработку или изобретение схемы преобразования спецификации приложения в готовое приложение. Проектирование — это тот процесс, который связывает выработку требований с кодированием и отладкой. Структура удачного высокоуровневого проекта приложения может успешно охватывать целый ряд более низкоуровневых проектов. Хорошее проектирование полезно при работе над небольшими приложениями и просто необходимо при работе над крупными.
-- Стив Макконнелл, Совершенный код, 2010
</blockquote>

<p>
Есть множество видов проектирования, по различным характеристикам применяемого метода или подхода. В логическом подходе системного проектирования, ориентированном на модули, можно выделить в отдельную группу <span id="Основная задача-нисходящее проектирование"></span><strong id="нисходящее проектирование">нисходящее проектирование</strong> (сверху вниз или функциональное), <span id="Основная задача-восходящее"></span><strong id="восходящее">восходящее</strong> (снизу вверх или объектно-ориентированое), *<span id="Основная задача-эволюционное"></span><strong id="эволюционное">эволюционное</strong>* (метод расширения ядра), <span id="Основная задача-иерархическое проектирование модулей"></span><strong id="иерархическое проектирование модулей">иерархическое проектирование модулей</strong> (метод Джексона). Как правило, в реальной жизни применяются различные сочетания этих методов.
</p>

<p>
В данной статье будет рассмотрен нисходящий метод проектирвания (сверху вниз).
</p>

<div id="Проектирование"><h1 id="Проектирование" class="header"><a href="#Проектирование">Проектирование</a></h1></div>

<p>
Для проектирования сверху вниз необходимо понимать главную абстрактную функцию проектируемой системы. Такое проектирование происходит путем последовательных шагов уточнений. При каждом шаге уточнения уровень абстракции системы в целом должен уменьшаться. С каждым шагом операция разбивается на композицию более простых операций.
</p>

<p>
Рассмотрим для примера такую задачу: необходимо рассчитать зарплату для работника за месяц.
</p>

<p>
Можно представить простейший алгоритм решения, который базируется на формуле расчета.
</p>

<ul>
<li>
Получить данные о работнике.

<li>
Получить количество часов.

<li>
Рассчитать зарплату по формуле.

</ul>

<p>
На каждом шаге проектировщик должен проверять оставшиеся элементы к уточнению и раскрывать их, используя тот же механизм. Уточнение заканчивается, когда на самом низком уровне абстракции допускается реализация.
</p>

<p>
Для нисходящего метода важно начинать проектирование с описания программы, и затем переходить к детализации конкретных элементов. На практике нужно определить, что программа будет делать на самом высоком уровне и уже после этого начинать детализацию, касающейся каждого конкретного действия. Нужно составить список действий, которые будет выполнять программа. Каждый элемент списка должен представлять только одну функциональность. Можно представлять каждый элемент как черный ящик на этом этапе. Затем, нужно более подробно описать каждый функциональный элемент как функциональный модуль. Это можно сделать например на уровне псевдокода или блок схемы, начиная описание от основного цикла.
</p>
<blockquote>
Итерация полезна на многих этапах разработки ПО. При разработке первоначальной спецификации системы вы составляете с заказчиком несколько версий требований, пока не достигнете согласия. Это итеративный процесс. Гибкий процесс разработки, предусматривающий создание и поставку системы по частям, тоже итеративен. Прототипирование, имеющее целью быструю и дешевую разработку предварительных вариантов решений, — еще одна форма итерации. Итеративная выработка требований, наверное, не менее важна, чем любой другой аспект процесса разработки ПО. Проекты завершаются неудачей потому, что разработчики приступают к решению проблемы, не изучив альтернативных вариантов. Итерация позволяет лучше узнать систему перед ее созданием.
-- Стив Макконнелл, Совершенный код, 2010
</blockquote>

<p>
Для демонстрации, вернемся к задаче, описанной выше и проведем функциональную декомпозицию, беря в основу ее главную функцию и составляющие действия.
</p>

<p>
Расчет заработной платы:
</p>
<ul>
<li>
запросить имя работника

<li>
получить данные работника

<li>
рассчитать сумму по формуле

<li>
напечатать результат

</ul>

<p>
Теперь имея больше деталей, нужно продолжить разбивать полученные функции на более мелкие.
</p>

<p>
Запросить имя работника:
</p>
<ul>
<li>
показать форму запроса

<li>
проверить введенные данные

<li>
вернуть строку

</ul>

<p>
Получить данные работника:
</p>
<ul>
<li>
прочитать имя работника

<li>
выполнить запрос

<li>
вернуть структуру данных

</ul>

<p>
Рассчитать сумму по формуле:
</p>
<ul>
<li>
прочитать структуру данных пользователя

<li>
подставить данные в формулу

<li>
вернуть число

</ul>

<p>
Напечатать результат:
</p>
<ul>
<li>
прочитать число

<li>
отформатировать число

<li>
напечатать сумму

</ul>
<p>
'a
В дальнейшем понадобится определить каждый из этих модулей в отдельности. Если при их описании будут создаваться новые функциональные элементы, то они должны быть также описаны.
</p>

<p>
Отформатировать число:
</p>
<ul>
<li>
прочитать число

<li>
применить формат отображения денежной единицы

<li>
вернуть строку

</ul>

<p>
Особое внимание заслуживает не определенная структура данных. Схема сейчас описывает “что” должна делать система, но не “как” (каким образом). Структуру данных, конечно же, нужно определить до начала кодирования. Это определение и его реализация задаст еще один уровень ограничений будущей системы.
</p>
<blockquote>
В высококачественном приложении должна быть очевидна связь между концептуальной целостностью архитектуры и ее низкоуровневой реализацией. Реализация должна соот ветствовать высокоуровневой архитектуре и обладать внутренней согласованностью.
-- Стив Макконнелл, Совершенный код, 2010
</blockquote>

<p>
Когда все функциональные элементы определены, можно начинать писать код.
</p>

<p>
Достоинства нисходящего метода проектирования:
</p>
<ul>
<li>
метод проектирования сверху вниз логичен, организует дисциплину мышления

<li>
помогает систематизировать знания на раннем этапе проектирования системы

<li>
позволяет поставить во главу процесса бизнес потребности и проблемы

</ul>

<p>
Недостатки нисходящего метода проектирования:
</p>
<ul>
<li>
задача “описать всю систему целиком” является достаточно сомнительной

<li>
метод не способен учесть эволюционную природу программных систем.

</ul>
<blockquote>
Как только мы разделяем уровни, мы невольно устраняем взаимосвязь и взаимодействие между ними, выводим явление или предмет из естественного контекста, в котором они существуют. В результате, чем «уже», конкретнее задача, тем больше требуется абстрагироваться от реальности, вводя новые допущения.
-- <a href="http://www.treko.ru/show_article_1090">Блашенкова В. Методы социологического исследования</a>
</blockquote>

<p>
Эволюция системы предполагает, что главная функция системы со временем может перестать быть главной. В примере выше функция системы расчета зарплаты предполагает вычисление размера зарплаты и вывод отчета. В требованиях описана функциональная часть системы.
</p>

<p>
Представим, что разработка на данном этапе завершена и программа выполняет свою задачу полностью. Скорее всего разработка на этом этапе не прекратится. Хорошие системы имеют раздражающую тенденцию для разработчиков перфекционистов — возбуждать в пользователях новые идеи о функциях, которую система может делать.
</p>
<blockquote>
Функциональный метод проектирования сверху вниз предназначен для случаев, когда проблема строго очерчена и задание состоит в вычислении одной функции — вершины проектируемой системы.
-- Бертран Мейер. Основы объектно-ориентированного программирования, 2016
</blockquote>

<p>
Как разработчик вы получили задание сделать расчет и генерацию отчета. И вслед за этим появляются просьбы расширить набор функций.
</p>

<ul>
<li>
<em>Заказчик</em>: Мы могли бы выводить дополнительную статистику?

<li>
<em>Разработчик</em>: Да. Понадобится только ввести дополнительную таблицу в базе данных, куда будем сохранять полученные вычисления.

<li>
<em>Заказчик</em>: Давайте сделаем генерацию отчетов систематической, каждый месяц?

<li>
<em>Разработчик</em>: Думаю мы могли бы делать это в конце каждого месяца.

<li>
<em>Заказчик</em>: А для некоторых работников мы можем делать отчеты два раза в месяц?

</ul>

<p>
Процесс изменений происходит непрерывно. Новая система продолжает все еще быть системой расчета заработной платы. Но ее главная функция, которая изначальна выглядела самой важной, становится просто одной из функций системы. А иногда совсем исчезает, становясь ненужной.
</p>

<ul>
<li>
<em>Заказчик</em>: Для администрации нужен суммарный ежемесячный отчет.

<li>
<em>Заказчик</em>: Акционеры просят делать ежеквартальные отчеты. Мы можем добавить такую функцию?

<li>
<em>Разработчик</em>: Хм… Конечно, мы могли бы…

<li>
<em>Разработчик</em>: А вы не могли это сказать с самого начала? Система работает сейчас в рамках только одного месяца!

</ul>

<p>
Итак, нужно добавить функциональность в систему. В результате в системе расчета зароботной платы появляется функция, которая косвенно связана с первоначальной задачей — сбор статистики и генерация отчетов. Структура системы может существенно изменить. Возможно понадобится выделить вспомогательный модуль в системе. Изменения наверняка затронут главный модуль системы, который теперь выполняет более широкий спектр задач. Возможно, что вам даже захочется изменить название системы.
</p>
<blockquote>
Если при анализе и проектировании используется метод декомпозиции, основанный на функции, то структура системы будет вытекать из исходного понимания разработчиками главной функции системы. При этом добавление новой функции, даже если это выглядит простой задачей для заказчика, может разрушить всю структуру системы. Поэтому важно найти в качестве критерия декомпозиции свойства более стабильные, чем главная функция системы.
-- Бертран Мейер. Основы объектно-ориентированного программирования, 2016
</blockquote>

<p>
В таком примере проблема относится к расширяемости, и если более точно, то качество системы не удовлетворяет критерию непрерывного расширения. Обеспечение непрерывности крайне важно при составлении реального жизненного цикла программных систем. Учитывать нужно не только первоначальную версию, но и эволюцию системы на протяжении долгого времени. Модель разработки системы, которая этого не учитывает, весьма далека от реальной жизни.
</p>
<blockquote>
Метод проектирования, удовлетворяет критерию непрерывности, если он приводит к устойчивой архитектуре и обеспечивает объем изменений соразмерный объему изменений в спецификациях.
-- Бертран Мейер. Основы объектно-ориентированного программирования, 2016
</blockquote>

<p>
Вполне вероятно, что диалог заказчика и разработчика может закончиться следующим
</p>

<ul>
<li>
<em>Заказчик</em>: А мы могли бы?..

<li>
<em>Разработчик</em>: Нет. Иначе мне придется все переписать.

<li>
<em>Заказчик</em>: Почему?

</ul>

<p>
Ответ скорее всего будет содержать отсылку к неправильно спректированной архитектуре системы.
</p>

<p>
Чтобы оценить качество архитектуры или метода проектирования, который к ней привел, нужно понять не только факт, насколько просто было ее получить, но и насколько просто ее можно изменить.
</p>
<blockquote>
One of the differences between building architecture and software architecture is that a lot of decisions about a building are hard to change. It is hard to go back and change your basement, though it is possible.
</blockquote>
<p>
  -- <a href="https://martinfowler.com/ieeeSoftware/whoNeedsArchitect.pdf">Martin Fowler, Who needs an Architect? (PDF)</a>
</p>

<div id="Недостатки"><h1 id="Недостатки" class="header"><a href="#Недостатки">Недостатки</a></h1></div>

<p>
Любой метод проектирования имеет свои недостатки. Важно понимать, как избежать тех или иных проблем, связанных с развитием и масштабированием системы.
</p>

<p>
В последнем примере останется, пожалуй, только определить самый главный уровень программы. Очень дорого может стоить применение преждевременного упорядочивания. Примером может служить преждевременная фиксация временных ограничений.
</p>

<p>
Уточняя каждый абстрактный уровень элементов, определяются зависимости элементов и порядок их вызова. В то же время, каждый элемент может быть подвержен изменениям. Представьте, что в основный цикл программы нужно внести коррективы:
</p>

<ul>
<li>
данные должны обновляться с периодичностью, для поддержания актуальности информации после вывода

<li>
в любой момент работы программы нужно позволять изменить входное значение

<li>
шаг ввода данных может быть пропущен, программа должна завершить работу

<li>
вывод данных на экран заменить на сохранение в память

<li>
программа должна обрабатывать ввод множественных данных.

</ul>

<p>
К сожалению, функциональное проектирование сверху вниз не обеспечивает достаточной гибкости архитектуры для непрерывного расширения. Мы вынуждены менять порядок выполнения операций и их компоновку до тех пор, пока не поймем, “что” главная функция должна делать и “как”, в какой последовательности будут выполняться операции.
</p>

<p>
Стоит заметить, что объектно-ориентированный метод также подвержен проблеме преждевременного упорядочивания.
</p>

<div id="Решения"><h1 id="Решения" class="header"><a href="#Решения">Решения</a></h1></div>

<p>
В качестве решения можно предложить метод не нумерованного списка и проектирование взаимосвязей по принципу контракта. Другими словами, каждый элемент помещается в общий список как доступная операция. Далее модули рассматриваются как отдельные модули. Если какой-то функциональный модуль требует значение, которое расчитывается в другом модуле, то ввод связи вида клиент-поставщик как ограничение будет обоснованным.
</p>

<p>
Использование простых структур данных поможет облегчить внесение изменений на ранних этапах. Иначе можно получить избыточную структуру или структуру, которая будет тяжело подвергаться изменениям или не отражать реальный предмет, на конкретном этапе эволюции системы
</p>

<p>
Важно следить за относительной прозрачностью функциональных модулей. Чтобы добиться соответствия системы критерию относительной прозрачности функций, нужно добиться независимости одних функционых модулей от других конкретных. Если можно заменить вызов функции на возвращаемое значение, и состояние при этом не изменится, то можно считать, что функция относительно прозрачна. Этот совет можно свести к рекомендации использовать <a href="https://wikipedia.org/wiki/Pure_function">чистые функции</a>, чтобы избежать побочных эффектов в системе. Также можно свести совет к рекомендации соблюдения принципов <a href="https://wikipedia.org/wiki/Single_responsibility_principle">SRP (Single Responsibility Principle)</a> и <a href="https://wikipedia.org/wiki/KISS_principle">KISS (Keep it simple)</a>, что приведет к легкой поддержке функциональных модулей. У каждого компонента должна быть одна зона ответственности и изменние логики должно быть оправдано поведением в рамках этой зоны.
</p>

<p>
Проект системы должен быть рассмотрен в разрезе возможности переиспользования модулей (компонентов) и следование принципу <a href="https://wikipedia.org/wiki/Don%27t_repeat_yourself">DRY (Don't repeat yourself)</a>. Если функция может выполнять отдельную часть работы, то не нужно делать похожую функцию, которая аггрегирует в себя ее функциональность. Стоит пересмотреть описание таких модулей (функций) на предмет отношенния клиент-поставщик. Возможно понадобится заменить выделенный на этапе функциональной декомпозиции функциональный модуль и заменить его двумя зависимыми, воспользовавшись методами рефакторинга из <a href="https://refactoring.com/catalog/">онлайн каталога Мартина Фаулера</a>
</p>
<blockquote>
Идеальная техническая система — это система, вес, объем и площадь которой стремятся к нулю, хотя её способность выполнять работу при этом не уменьшается. Иначе говоря, идеальная система — это когда системы нет, а функция её сохраняется и выполняется
-- Альтшуллер Г.С., Творчество как точная наука, 1979
</blockquote>

<p>
В какой-то степени это актуально и для программных систем в частности. В любом случае стоит стремиться к минимальным изменениям в системе, используя уже имеющиеся возможности окружения.
</p>

<ul>
<li>
<em>Заказчик</em>: Можно сделать так, чтобы программа генерировала отчеты самостоятельно и отправляла отчеты по почте?

<li>
<em>Заказчик</em>: Мы можем ввести графический интерфейс в программу, чтобы можно было просматривать все сгенерированные отчеты за последний месяц?

</ul>

<p>
Это уже больше похоже на систему отчетности, даже документооборота, в некотором смысле. И выглядит совсем не похоже на систему расчета зароботной платы.
</p>
</div>

    <footer><p><small>Page created on 2018-07-18</small></p></footer>
</body>
</html>
