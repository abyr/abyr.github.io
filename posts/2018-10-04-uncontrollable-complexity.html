<html>
<head>
		<link rel="Stylesheet" type="text/css" href="../style.css" />
		<title>Неконтролируемая сложность</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bdc32b9dc15cb1f\"></script>
     <script type=\"text/javascript\">
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-105032758-1', 'auto');
       ga('send', 'pageview');
    </script>

    <nav>
      <ul>
        <li>
          <a href="/">Index</a>
        </li>
      </ul>
    </nav>

    <h1>Неконтролируемая сложность</h1>
		<div class="content">
<div id="Contents" class="toc"><h1 id="Contents">Contents</a></h1></div>
<ul>
<li>
<a href="2018-10-04-uncontrollable-complexity.html#Неприятная статистика">Неприятная статистика</a>

<li>
<a href="2018-10-04-uncontrollable-complexity.html#Главный Технический Императив">Главный Технический Императив</a>

<li>
<a href="2018-10-04-uncontrollable-complexity.html#Контролируемая сложность">Контролируемая сложность</a>

<ul>
<li>
<a href="2018-10-04-uncontrollable-complexity.html#Контролируемая сложность-Упрощение на стадии проектирования">Упрощение на стадии проектирования</a>

<li>
<a href="2018-10-04-uncontrollable-complexity.html#Контролируемая сложность-На стадии разработки">На стадии разработки</a>

</ul>
</ul>


<div id="Неприятная статистика"><h1 id="Неприятная статистика" class="header"><a href="#Неприятная статистика">Неприятная статистика</a></h1></div>

<p>
Самое неприятное, что может произойти с проектом — это его конец. Я не имею в виду конец на его финальной стадии, хотя совершенству предела нет и стадию поддержки также необходимо учитывать. Куда хуже ситуация, когда программный проект больше не может продолжаться, не достигнув успешного результата. Это происходит достаточно часто. Если посмотреть статистику провальных стартапов, то можно увидеть в списке частых причин нехватку ресурсов в виде инвестиций, а также проблему человеческих ресурсов. В частности, достаточно высокий коэффициент провалов или остановок по причине “Not the Right Team”. Идея продукта может меняться вместе с рынком, но люди должны быть надёжными и, самое главное, предсказуемыми.
</p>

<p>
<img src="https://cdn-images-1.medium.com/max/800/1*60_s8FrwZH3ZCAlcGWl_OA.png" alt="20 biggest reasons why startup companies fail" />
</p>

<p>
<a href="https://medium.com/r/?url=https%3A%2F%2Fwww.marketwatch.com%2Fstory%2F20-biggest-reasons-why-startup-companies-fail-2015-06-16">https://medium.com/r/?url=https%3A%2F%2Fwww.marketwatch.com%2Fstory%2F20-biggest-reasons-why-startup-companies-fail-2015-06-16</a>
</p>

<p>
Насколько я могу видеть, то в open-source проектах часто встречается ситуация, когда проект перестает поддерживаться, когда у автора пропадает интерес к изначальной идее, не хватает времени или разработка заходит в тупик. У разработчиков может размыться видение линии развития проекта. Или например не хватает терпения поддерживать ошибки в проектировании системы. Или вовсе не хватает сил менять решение, которое требует изменений в архитектуре. Такое происходит даже с востребованными и уникальными проектами, имеющих пользовательскую базу. И несмотря на популярность и востребованность проекта достаточно сложно найти человека, который будет продолжать и развивать идею. зачастую из-за высокго порога вхождения в изучении системы или высокой стоимости внесения изменений.
</p>

<div id="Главный Технический Императив"><h1 id="Главный Технический Императив" class="header"><a href="#Главный Технический Императив">Главный Технический Императив</a></h1></div>
<blockquote>
Программные проекты редко терпят крах по техническим причинам. Чаще всего провал объясняется неадекватноий выработкой требований, неудачным планированием или неэффективным управлением. Если же провал обусловлен все-таки преимущественно технической причиной, то очень часто ею оказывается неконтролируемая сложность. Иначе говоря, приложение стало таким сложным, что разработчики перестали по-настоящему понимать, что же оно делает. Если работа над проектом достигает момента, после которого уже никто не может полностью понять, как изменение одного фрагмента программы повлияет на другие фрагменты, прогресс прекращается.
-- Стив Макконнелл, Совершенный код, 2010
</blockquote>

<p>
Эту цитату хорошо подсуммирует фраза:
</p>
<blockquote>
…programming is a desperate losing battle against the unconquerable complexity of code…
-- <a href="https://alarmingdevelopment.org/?p=79">Beautiful Code by Jonathan Edwards</a>
</blockquote>

<p>
Можно сказать, что борьба со сложностью является непрерывным процессом.
</p>

<p>
Бертран Мейер в своей книге “Основы объектно-ориентированного программирования” вводит ряд критериев, определяющих качество системы. Среди них “расширяемость” —  легкость адаптации ПО к изменениям спецификации. Также присутствует “простота использования” — это легкость, с которой люди с различными знаниями и квалификацией могут научиться использовать ПО и применять его для решения задач. Сюда же относится простота установки, работы и текущего контроля.
</p>

<p>
Можно сделать следующий вывод, что такое качество, как “сложность” негативно влияет на показатели хорошего качества системы, и может оказаться пагубным для жизненного цикла системы на каждой из стадий, так как имеет свойство накапливаться.
</p>
<blockquote>
Управление сложностью – самыий важныий техническиий аспект разработки ПО. По-моему, управление сложностью настолько важно, что оно должно быть Главным Техническим Императивом Разработки ПО."
-- Стив Макконнелл, Совершенный код, 2010
</blockquote>

<div id="Контролируемая сложность"><h1 id="Контролируемая сложность" class="header"><a href="#Контролируемая сложность">Контролируемая сложность</a></h1></div>
<p>
Но как же сделать систему более простой? Ответ очевиден — нужно ее упрощать. Этот процесс может происходить как на стадии проектирования, так и на стадии разработки.
</p>

<div id="Контролируемая сложность-Упрощение на стадии проектирования"><h2 id="Упрощение на стадии проектирования" class="header"><a href="#Контролируемая сложность-Упрощение на стадии проектирования">Упрощение на стадии проектирования</a></h2></div>

<p>
На стадии проектирования в рамках процесса декомпозиции стоит выделить и разделить модули, которые предполагают частые изменения, а также модули, которые изменений в будущем не потребуют. Если модуль занимается выводом данных на устройство по шаблону, то вряд ли этот модуль будет часто меняться. Скорее будет меняться сам шаблон — данные и формат.
</p>

<p>
Модули не должны быть завязаны друг на друга, иначе адаптация системы под именение в одном модуле будет в своем процессе возвращаться к модулю с изначальной правкой. В случае допущения ошибки симптомы могут оказаться неявными для конкретного модуля и процесс отладки заставит вас пересмотреть все измененные модули.
</p>

<p>
Использование абстракций помогает добиться от системы соответствия принципу сокрытия информации, описанным Бертраном Мейером:
</p>
<blockquote>
Разработчик каждого модуля должен выбрать некоторое подмножество свойств модуля в качестве официальной информации о модуле, доступной авторам клиентских модулей.
Применение этого правила означает, что каждый модуль известен всем остальным (то есть разработчикам других модулей) через некоторое официальное описание, или так называемые общедоступные (public) свойства.
-- Бертран Мейер. Основы объектно-ориентированного программирования, 2016
</blockquote>

<p>
Использование этого правила на стадии проектирования приводит к разделению уровней абстракий в модулях, что в свою очередь помогает добиться и сокрытия сложности. Таким образом вводятся дополнительные уровни, которые независимо от других уровней решают сложные задачи на небольшом уровне.
</p>

<p>
Еще один спооб контролировать сложность — использовать стандартные методики проектирвоания модулей и применять проверенные шаблоны проектирования.
</p>

<p>
<a href="https://medium.com/r/?url=https%3A%2F%2Fwww.martinfowler.com%2Farticles%2FwritingPatterns.html">Writing Software Patterns</a>
</p>

<div id="Контролируемая сложность-На стадии разработки"><h2 id="На стадии разработки" class="header"><a href="#Контролируемая сложность-На стадии разработки">На стадии разработки</a></h2></div>

<p>
Важно следить и вовремя определить, что уровень сложности системы требует вмешательства и упрощения. Самый простой способ — спросить мнение опытного товарища или коллег. Частые жалобы на отдельные модули системы — верный признак, что выбран неудачный вариант решения задачи.
</p>

<p>
<img src="https://cdn-images-1.medium.com/max/800/1*5RhyUqWmrXugwrjchoA5rA.jpeg" alt="The only valid measurement of code quality: WTFs/minute" />
</p>
<blockquote>
Одним из симптомов того, что вы погрязли в чрезмерно̆й сложности, является упрямое применение метода, нерелевантность которого очевидна по крайней мере любому внешнему наблюдателю. При этом вы уподобляетесь человеку, который при поломке автомобиля в силу своеий некомпетентности не находит ничего лучшего, чем заменить воду в радиаторе и выбросить окурки из пепельниц.
-- Ф. Дж. Плоджер (P. J. Plauger)
</blockquote>

<p>
Необходимо следить за чистотой кода. Нечитаемый или непонятный код с высокой вероятностью будет исправлен неверно в будущем. Также такой код проблематично покрывать тестами после реализации. Если такой код не работает корректно с абсолютной веротяностью, то с такой же вероятностью он будет полностью переписан. Зачастую это требует меньше времени, чем эмпирическое исследование путем отладки с повторяющимися условиями, поскольку качественный эксперимент предполагает только одно изменение за раз.
</p>

<p>
В решении задач необходимо использовать эффективные решения. Любые задачи должны решаться верным способом, не допускающим вероятность ошибки. Нужно стремиться всегда находить наиболее простое решение.
</p>

<p>
Не стоит забывать, что на стадии разработки стадия проектирования не заканчиается. Всякий раз, вводя новый архитектурный элемент, стоит убедиться, что в достаточной мере выполнена декомпозиция, модули слабо зацеплены между собой и все элементы модулей отвечают цели — главной функции и система в целом не страдает.
</p>
</div>

    <footer><p><small>Page created on 2018-10-04</small></p></footer>
</body>
</html>
